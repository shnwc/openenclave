Notes on OE SDK Attestation API and Plugin Library Design
====

This document contains notes on the concepts and assumptions behind the design
of the TEE-agnostic OE SDK Attestation API as described in document
[Proposal of OE SDK Attestation Public and Plugin API for V0.10 Release](https://github.com/openenclave/openenclave/pull/2949)
(as of March 2020).
It also captures notes on the design of SGX plugins as explained in document
[Attestation: OE SDK Integration with Intel® SGX SDK quote-ex Library for Generation of Evidence in New Formats](https://github.com/openenclave/openenclave/blob/master/docs/DesignDocs/SGX_QuoteEx_Integration.md).

Hopefully these notes can help readers' understanding of the API and its
usage, and the SGX plugin design.

# Notes on TEE-agnostic OE SDK Attestation API Design

## Semantics of Custom Claims and Optional Parameters

Among all the parameters for the OE SDK API function `oe_get_evidence()`,
two of them are a list of custom claims (`custom_claims`) and an optional
parameters blob(`opt_params`). While in general the fields in these two
parameters fit the definition of the term "Claims" defined in the
[RATS document](https://tools.ietf.org/html/draft-ietf-rats-architecture),
in the context of the function `oe_get_evidence()`, these two parameters
have distinct semantics that might not be straightforward to application
and plugin software developers.

To help clarify what goes into the custom claims (`custom_claims`) and
what goes into the optional parameters (`opt_params`) in the function
`oe_get_evidence()`, it would be good to articulate the semantics of these
two entities.

- Custom claims have well-defined semantics:
  - Custom claims can be any name-value pair.
  The name and the value fields are null-terminated byte strings.
  Other than that, there is no additional requirement on their format or content.
  - Custom claims are only meaningful to attester / verifier applications.
  They are not inspected or interpreted by the OE SDK or its plugins.
  - They are always TEE agnostic
  - Custom claims are included and signed in the evidence as clear text
  by an attester for integrity protection.
  On the verifier side, they are verified by a verifier plugin
  as part of the evidence verification, and presented to the verifier
  application for processing.
    - Secrets shall never be included as a custom claim. Instead a hash of
    a secret can be included by an attester as a custom claim in its evidence,
    and passed to a verifier with integrity protection. The secret itself
    has to be passed from the attester to the verifier with confidentiality
    protection. Integrity of the secret can be verified by the verifier
    using the hash held as a custom claim in the evidence.
  - Custom claims can cover attester instance identity or
  properties.
    - This type of custom claims are created and maintained by the attester
    and not received from a verifier.
    - This type of claims are passed to verifiers with integrity protection
    as part of the evidence, so verifiers can use the claims to learn the
    identity and properties for the attester and for secure communication
    with the latter.
    - The public key of an asymmetric key-pair generated by an attester,
    serving as an unique public identity of the attester,
    is a good example of a custom claim.
  - Custom claims can also be created by a verifier application and passed to
  an attester for inclusion in the evidence.
    - This type of claims allows the attester to make assertions about
    its evidence to the targeted verifier.
    - A good example of this type of claims is a nonce generated by a
    verifier application and passed to an attester for inclusion in an
    evidence, for evidence freshness.
      - This nonce is generated by the verification application itself,
      and not by its verifier plugins.
      - On the attester side, the OE SDK attester plugin simply includes it
      in the newly-generated evidence, and does not do any interpretation.
      - Upon successful verification of the evidence, if its nonce is included
      in the evidence, the verifier application can be sure that the
      evidence is fresh.

- Optional parameters semantics are the opposite of that of custom claims:
  - They are TEE and evidence format specific
  - They are interpreted and processed by OE SDK attester and verifier plugins
    - Typically, optional parameters are provided by a verifier to an attester,
    so the attester can generate the correct evidence that can be
    verified by the verifier
  - They are not interpreted nor processed by attester / verifier
  application software
  - An SGX target info for local  attestation is a good example of
  optional parameter, as explained in the paragraphs below.

For SGX local attestation, the SGX target info generated by a
verifier enclave for an attester enclave is a perfect fit for the optional
parameters in the attester enclave's call to `oe_get_evidence()`:
- The target info is SGX specific, and is not parsed nor interpreted
by the TEE-agnostic application code.
- The SGX target info is generated by the verifier API function
`oe_verifier_get_format_settings()` for SGX local attestation,
and passed by the calling verifier application as an opaque blob to an
attester enclave.
- The attester enclave invokes its SGX local attestation attester plugin via
`oe_get_evidence()`, passing in the received SGX target info as an opaque blob,
to generate an evidence containing the SGX report targeted for the
verifier enclave.
- This SGX report can only be verified by the verifier plugin of the verifier
enclave that generated the SGX target info.
Any other verifier enclaves, either running on the local or a remote platform,
won’t be able to verify this SGX report.

## Attester – Verifier Security Model and TEE Agnostic Design

- The OE SDK is designed for attester and verifier software to be TEE agnostic,
so that the same source code can be built for and run on different platforms
- But owners of attesters and verifiers define their security policies,
and the policies are not TEE agnostic. For example:
  - The policies define which TEEs, platforms and configurations are trusted
  to run the attesters and verifiers.
    - They also define security properties of these entities, e.g. keypairs
    and certs, service provider ID / SPID for SGX EPID evidence, etc.
    These security properties are required for attestation and secure
    communication.
  - The policies define the list of evidence formats acceptable to the verifiers.
    - Many acceptable evidence format are TEE specific. Examples include
    SGX location attestation evidence formats, SGX ECDSA evidence formats,
    and SGX EPID evidence formats.
- The OE SDK provides means for the attesters and verifiers to be built and
configured for specified TEEs and platforms, and to generate or verify evidences
in the list of acceptable formats as defined in the security policies.
  - The OE SDK attestation API enables the attesters and verifiers to register
  the plugins that are built, configured, and working
  properly, and enumerate the supported list of evidence formats covered by
  these plugins.
  For a specific attester or verifier instance, the supported list
  of evidence formats is not required to perfectly match the acceptable list
  defined in the security policies.

# Notes on SGX Plugins Design

## Evidence Format, Plugin, and Plugin Library

In the OE SDK attestation API described in document
[Proposal of OE SDK Attestation Public and Plugin API for V0.10 Release](https://github.com/openenclave/openenclave/pull/2949),
every evidence format is uniquely identified by a UUID. Enclave and host
applications can discover formats supported for evidence verification.
Enclave applications can select a format for evidence generation. For evidence
generation, API `oe_get_evidence()` takes in an evidence format UUID along with
other input parameters. Upon successful operation, `oe_get_evidence()` returns
an evidence blob with the evidence format UUID included as a field in its
header structure.

In the OE SDK attestation plugin design, a plugin is a logical unit that exposes
a set of API entry points for evidence generation or verification, as defined
in this [header file](https://github.com/openenclave/openenclave/blob/master/include/openenclave/attestation/plugin.h).
To some extent, a plugin is analogous to a C++ object, which exposes methods
for interaction with other entities.
A plugin can either be an attester plugin or a verifier plugin.
Each plugin is associated with a single evidence format UUID.

In theory multiple plugins can exist in a configuration for the same format,
though in practice this should not be implemented as there is no clear benefit
for the added complexity in implementation.

Please note that an evidence format does not just identify a syntactic data format
contract as the word "format" may suggest. It further identifies a semantic or
behavior contract. In the context of the OE SDK attestation plugin design,
a primary use of the of the evidence format UUID is to identify which verifier
plugins work with which attester plugins. A verifier plugin associated with a
specific UUID is guaranteed to be able to verify evidence generated by an
attester plugin associated with the same UUID.

In an implementation of the OE SDK design, the set of supported plugins
are implemented by one or more enclave-side and / or host-side plugin libraries and
their dependencies. These plugin libraries can either be static or shared
libraries, as supported by the build environment. There is no one-on-one
mapping between plugins and plugin libraries.
A single plugin may be implemented by multiple plugin libraries. For example,
an enclave-side attester plugin for SGX ECDSA evidence needs an enclave-side
plugin library and a host-side plugin library. On the other hand,
a single set of plugin libraries can implement multiple plugins. For example,
both the enclave-side SGX ECDSA and EPID attester plugins are implemented by
the same set of SGX attester plugin libraries.

## Options for Enclave-side Plugin Library Initialization

As described in the latest version (as of March 2020) of the design document
[Attestation: OE SDK Integration with Intel® SGX SDK quote-ex Library for Generation of Evidence in New Formats](https://github.com/openenclave/openenclave/blob/master/docs/DesignDocs/SGX_QuoteEx_Integration.md),
enclave-side plugin library initialization of attester plugins can be
triggered by application enclave call of the OE SDK API
`oe_attester_initialize()`. The OE SDK framework and plugin library
implementation enumerates and registers all attester plugins configured
for the platform and the calling application.

In general, there are several options for initialization of enclave-side
plugin libraries while keeping application enclaves TEE agnostic.

In this section, we focus on the discussion of the options for initialization
of attester plugins. Same options are available for initialization of
enclave-side verifier plugins.

1. Every enclave-side plugin library implements the same OE SDK API
`oe_attester_initialize()`.

    With this option, a build of an application enclave project can only be linked
    with a single attestation plugin library, to avoid function name collision.

2. Build-time macro to convert from TEE-agnostic API to TEE-specific
implementation.

    With this option, application enclaves still call TEE-agnostic OE SDK API
    `oe_attester_initialize()`.
    But the OE SDK provides a macro definition of this function calling
    the TEE- and library-specific initialization functions of linked
    enclave-side plugin libraries.

    This option has the potential to support linking with multiple
    enclave-side plugin libraries in a single application enclave build
    configuration.
    The OE SDK build environment is required to provide a proper
    `oe_attester_initialize()` macro definition for every configuration
    it supports.

3. Build-time manifest to list plugin libraries and their
initialization entry points

    With this option, every plugin library has its own initialization
    entry point with globally unique name and well-defined prototype.
    To build and sign an attester application enclave, a manifest / metadata
    (.conf file) is created that contains the list of linked enclave-side
    plugin libraries and their entry points. This manifest is compiled and
    signed as part of the attester enclave image.

    During run-time, upon load of an application enclave, its OE SDK framework
    reads its embedded manifest, retrieves the addresses of all the listed
    initialization function entry points, and invokes them in the order listed.

    Note: this option requires the definition of the manifest format and the
    new capability for the OE SDK build and signing tools to support processing of
    manifest files.

4. Run-time enclave-side plugin libraries registration of their initialization
functions with the OE SDK framework.

    The design document
    [OpenEnclave Modules](https://github.com/jhand2/openenclave/blob/global_module_initialization/docs/DesignDocs/openenclave_modules.md)
    describes how an enclave-side module can register its initialization
    function for invocation on first entry to the enclave (upon enclave load).

    With this option, the implementation of the OE SDK attestation framework
    provides a hook for enclave-side plugin libraries to register their
    initialization functions upon enclave load.

    If ordering between the initialization functions of multiple libraries is
    required, it can be supported by assigning different priorities to the
    initialization functions of these libraries when they are registered
    upon load.

    Later, when the application enclave calls `oe_attester_initialize()`,
    the implementation of this function in the OE SDK framework calls all the
    registered plugin library initialization functions in the order of their
    priorities, to initialize all plugin libraries and to enumerate all
    supported evidence formats by all the plugin libraries.

    This option allows the OE SDK framework to link with multiple plugin libraries.
    It even has the potential to support dynamic link / load of enclave-side
    plugin libraries, as long as the function `oe_attester_initialize()` is
    implemented as idempotent, so that it can be invoked multiple times,
    each time after a new plugin library is loaded.

    Note: to enable this option, the OE SDK attestation framework has to be
    initialized with the needed locks and list structure, before plugin
    libraries can register their initialization functions.

## Options for Host-side Plugin Library Initialization

In addition to enclave-side attester and verifier plugins, OE SDK also supports
host-side verifier plugins. Options for host-side plugin libraries
initialization are similar to that for enclave-side plugin libraries
initialization, with some differences as discussed below.

1. Every host-side verifier plugin library implements the same OE SDK API
`oe_verifier_initialize()`.

    With this option, a build of an OE SDK host verifier application can only
    link with a single verifier plugin library, to avoid function name collision.

    But if the host-side verifier plugin libraries are dynamically loaded,
    then the above limit no longer applies. Arbitrary number of shared
    libraries can be loaded, and all of them can have entry points of the
    same name. This is described as option 3.

2. Build-time macro to convert from TEE-agnostic API to TEE-specific
implementation.

    With this option, OE SDK host applications still call TEE-agnostic
    OE SDK API `oe_verifier_initialize()`.
    But the OE SDK provides a macro definition of this function calling
    the TEE- and library-specific initialization functions of linked
    host-side plugin libraries.

    The OE SDK build environment is required to provide a
    `oe_verifier_initialize()` macro definition for every configuration
    it supports.

3. Load-time manifest to list plugin libraries and their initialization
entry points

    With this option, for an OE SDK host verifier application,
    a manifest file (.conf file) is provided, with a list
    of supported verifier plugin libraries (shared) and their entry point
    names.

    During run-time, when the OE SDK host application starts, its OE SDK
    host-side framework reads in the manifest file, dynamically loads
    the listed host-side verifier plugin shared libraries, finds the addresses
    of the listed entry points, and calls them in the order listed.
    The initialization functions of all the plugin libraries can have the
    same name.

    Host applications are not signed. Manifest files are not signed either.

4. Run-time host-side plugin libraries registration of their initialization
functions with the OE SDK framework.

    C/C++ global constructors can be used for this purpose.
    An explanation of them can be found in
    [this document](https://wiki.osdev.org/Calling_Global_Constructors).

    Note: to enable this option, the OE SDK host-side framework has to be
    initialized with the needed locks and list structure, before plugin
    libraries can register their initialization functions.

## Discussion

For initialization of enclave-side plugin libraries, option #3 (build-time
manifest to list plugin libraries and their initialization entry points)
is promising. It gives application enclave developers the most
control. But this option requires the OE SDK build and signing tools to
add support of manifests.

For initialization of host-side plugin libraries, option #3 (load-time
manifest to list plugin libraries and their initialization entry points)
is also promising, allowing load-time control of the list of
supported plugin libraries and the order in which these libraries are
initialized. But support of this operation requires the OE SDK host-side
framework to add capability to process manifests.

Before support of enclave-side and host-side option #3 or other advanced
options is available,
option 1 can be readily supported. The OE SDK attestation API and plugin
architecture can be designed so that, moving from option 1 to option 3,
there is no change in the public API and the plugins implementation.

# References

1. IETF draft [Remote Attestation Procedures Architecture](https://tools.ietf.org/html/draft-ietf-rats-architecture)
2. IETF draft [The Entity Attestation Token (EAT)](https://tools.ietf.org/html/draft-ietf-rats-eat)

# Authors

- Shanwei Cen (@shnwc)
