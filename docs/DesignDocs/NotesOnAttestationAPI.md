Notes on OE SDK Attestation API and Plugin Library Design
====

This document contains notes on the concepts and assumptions behind the design
of the OE SDK Attestation API as captured in document
[CustomAttestation_V3.md](https://github.com/openenclave/openenclave/blob/master/docs/DesignDocs/CustomAttestation_V3.md),
as well as the design of SGX plugins as described in document
[Attestation: OE SDK Integration with Intel® SGX SDK quote-ex Library for Generation of Evidence in New Formats](https://github.com/openenclave/openenclave/blob/master/docs/DesignDocs/SGX_QuoteEx_Integration.md).

Hopefully these notes can help the readers' understanding of the API and its
usage, and the SGX plugin design.

# Semantics of Custom Claims and Optional Parameters

To help clarify what goes into custom claims and what goes to optional
parameters in the `oe_get_evidence()` API function, it would be good to
articulate the semantics of these two fields.

- Custom claims have well-defined semantics:
  - Can be any name-value pair
  - Only meaningful to ISV attester / verifier applications
    - Typically, custom claims are part of an attester instance identity or
    properties. They are created and maintained by the attester and not
    received from a verifier
    - Examples include a public key or a nonce generated by an attester
    - These claims are passed to verifiers with integrity protection (as part
    of the evidence), so verifiers can use the claims to learn the identity
    and properties for the attester and for secure communication with the
    latter
  - They are always TEE agnostic
  - Signed and included in evidence as clear text by an attester plugin,
  and verified and reproduced by a verifier plugin, to ensure integrity
  protection in transmission from an attester application to an verifier
  application
    - Secrets shall never be included as a custom claim. Instead a hash of
    a secret can be included by an attester as a claim in its evidence,
    and passed to an verifier with integrity protection. The secret itself
    has to be passed from the attester to the verifier with confidentiality
    protection. Integrity of the secret can be verified by the verifier
    using the hash in the evidence.
  - Custom claims are NOT inspected or interpreted by OE SDK / plugins
- Optional parameters semantics are the opposite of that of custom claims:
  - They are TEE and evidence format specific
  - They are interpreted and processed by OE SDK attester and verifier plugins
    - Typically, optional parameters are provided by a verifier to an attester,
    so the attester can generate the correct evidence that can be successfully
    verified by the verifier
  - They are not interpreted nor processed by attester / verifier
  application software

For SGX local attestation, the SGX target info structure generated by an
verifier enclave for an attester enclave is a perfect fit for the optional
parameters in the attester enclave's call to `oe_get_evidence()`:
- For SGX local attestation, the SGX target info is generated by a verifier
enclave and passed to an attester enclave
- With the received target info, the attester enclave can generate an SGX
report targeted for the verifier enclave
- This SGX report can only be verified by the verifier enclave that provided
by target info. Any other enclaves, either running on the local or a remote
platform, won’t be able to verify this SGX report.
- The target info is SGX specific, and is not parsed nor interpreted
by the TEE-agnostic application code. It is handled by the SGX local
attestation plugins underneath the `oe_get_evidence()` and
`oe_verify_evidence()` API in the attester and the verifier respectively.

# Attester – Verifier Security Model and TEE Agnostic Design

- OE SDK is designed for attester and verifier software to be TEE agnostic,
so that the same source code can be built for and run on different platforms
- But owners of attesters and verifiers define their security policies,
and the policies are not TEE agnostic. For example:
  - The policies define which TEEs, platforms and configurations are trusted
  to run attesters and verifiers.
    - They also define security properties of these entities, e.g. keypairs
    and certs, service provider ID / SPID for SGX EPID evidence, etc.
    These security properties are required for attestation and secure
    communication.
  - They define which evidence formats attesters accept, and configure the
  list to the verifiers.
    - Every acceptable evidence format is TEE specific.
- OE SDK provides means for the attesters and verifiers to be built and
configured for specified TEEs and platforms, and to generate or verify
the evidence formats according to their defined security policies.
  - The OE SDK attestation API enables the attesters and verifiers to discover
  and register supported plugins that are built, configured, and working
  properly. For a specific attester or verifier instance, the supported list
  of evidence is not required to perfectly match the list defined in the
  security policies.

# Options for Enclave-side Plugin Library Initialization

As described in the design document
[Attestation: OE SDK Integration with Intel® SGX SDK quote-ex Library for Generation of Evidence in New Formats](https://github.com/openenclave/openenclave/blob/master/docs/DesignDocs/SGX_QuoteEx_Integration.md),
enclave-side plugin library initialization of attester plugins can be
triggered by application enclave call of the OE SDK API
`oe_get_attester_plugins()`.
During initialization, the plugin library enumerates supported evidence
formats, and returns a list of supported attester plugins.

In general, there are several options for initialization of enclave-side
plugin libraries while keeping application enclaves TEE agnostic.

In this section, we focus on the discussion of the options for initialization
of attester plugins. Similar options are available for initialization of
verifier plugins.

1. Every enclave-side plugin library implements the same OE SDK API
`oe_get_attester_plugins()`.

    With this option, a build of an application enclave project can only link
    with a single attestation plugin library, to avoid function name collision.

2. Compile-time macro to convert from TEE-agnostic API to TEE-specific
implementation.

    With this option, application enclaves still call TEE-agnostic OE SDK API
    `oe_get_attester_plugins()`.
    But the OE SDK provides a definition of this function as a macro calling
    into the TEE- and library-specific initialization functions of linked
    enclave-side plugin libraries.

    This option has the potential to support linking with multiple
    enclave-side plugin libraries in a single application enclave build
    configuration.
    The OE SDK build environment is required to provide a proper
    `oe_get_attester_plugins()` macro definition for every configuration
    it supports.

3. Every enclave-side plugin library registers its initialization function
with the OE SDK framework.

    The design document
    [OpenEnclave Modules](https://github.com/jhand2/openenclave/blob/global_module_initialization/docs/DesignDocs/openenclave_modules.md)
    describes how an enclave-side module can register its initialization
    function for invocation on first entry to the enclave (upon enclave load).

    With this option, the implementation of the OE SDK attestation framework
    provides a hook for enclave-side plugin libraries to register their
    initialization functions upon enclave load.
    To support ordering in the initialization of multiple plugin libraries,
    different plugin libraries can register their initialization functions
    at different priorities.

    Later, when the application enclave calls `oe_get_attester_plugins()`,
    the implementation of this function in the OE SDK framework calls all the
    registered plugin library initialization functions in the order of their
    priorities, to initialize all plugin libraries and to enumerate all
    supported evidence formats by all the plugin libraries.

    This option allows the OE SDK framework to link with multiple plugin libraries.
    It even has the potential to support dynamic link / load of enclave-side
    plugin libraries, as long as the function `oe_get_attester_plugins()` is
    implemented as idempotent, so that it can be invoked multiple times,
    each time after a new plugin library is loaded.

# Authors

- Name: Shanwei Cen
    - email: shanwei.cen@intel.com
    - github user name: shnwc