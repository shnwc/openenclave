Notes on OE SDK Attestation API and Plugin Library Design
====

This document contains notes on the concepts and assumptions behind the design
of the TEE-agnostic OE SDK Attestation API as described in document
[Custom Attestation Data Formats for Open Enclave V3 Updates](https://github.com/openenclave/openenclave/blob/master/docs/DesignDocs/CustomAttestation_V3.md)
(as of March 2020).
It also captures notes on the design of SGX plugins as explained in document
[Attestation: OE SDK Integration with Intel® SGX SDK quote-ex Library for Generation of Evidence in New Formats](https://github.com/openenclave/openenclave/blob/master/docs/DesignDocs/SGX_QuoteEx_Integration.md).

Hopefully these notes can help readers' understanding of the API and its
usage, and the SGX plugin design.

# Notes on TEE-agnostic OE SDK Attestation API Design

## Semantics of Custom Claims and Optional Parameters

Among all the parameters for the OE SDK API function `oe_get_evidence()`,
two of them are a list of custom claims (`custom_claims`) and an optional
parameters blob(`opt_params`). While in general the fields in these two
parameters fit the definition of the term "Claims" defined in the
[RATS document](https://tools.ietf.org/html/draft-ietf-rats-architecture),
in the context of the function `oe_get_evidence()`, these two parameters
have distinct semantics that might not be straightforward to application
and plugin software developers.

To help clarify what goes into the custom claims (`custom_claims`) and
what goes into the optional parameters (`opt_params`) in the function
`oe_get_evidence()`, it would be good to articulate the semantics of these
two entities.

- Custom claims have well-defined semantics:
  - Custom claims can be any name-value pair.
  The name and the value fields are null-terminated byte strings.
  Other than that, there is no additional requirement on their format or content.
  - Custom claims are only meaningful to attester / verifier applications.
  They are not inspected or interpreted by the OE SDK or its plugins.
  - They are always TEE agnostic
  - Custom claims are included and signed in the evidence as clear text
  by an attester for integrity protection.
  On the verifier side, they are verified by a verifier plugin
  as part of the evidence verification, and presented to the verifier
  application for processing.
    - Secrets shall never be included as a custom claim. Instead a hash of
    a secret can be included by an attester as a custom claim in its evidence,
    and passed to a verifier with integrity protection. The secret itself
    has to be passed from the attester to the verifier with confidentiality
    protection. Integrity of the secret can be verified by the verifier
    using the hash held as a custom claim in the evidence.
  - Custom claims can cover attester instance identity or
  properties.
    - This type of custom claims are created and maintained by the attester
    and not received from a verifier.
    - This type of claims are passed to verifiers with integrity protection
    as part of the evidence, so verifiers can use the claims to learn the
    identity and properties for the attester and for secure communication
    with the latter.
    - The public key of an asymmetric key-pair generated by an attester,
    serving as an unique public identity of the attester,
    is a good example of a custom claim.
  - Custom claims can also be created by a verifier application and passed to
  an attester for inclusion in the evidence.
    - This type of claims allows the attester to make assertions about
    its evidence to the targeted verifier.
    - A good example of this type of claims is a nonce generated by a
    verifier application and passed to an attester for inclusion in an
    evidence, for evidence freshness.
      - This nonce is generated by the verification application itself,
      and not by its verifier plugins.
      - On the attester side, the OE SDK attester plugin simply includes it
      in the newly-generated evidence, and does not do any interpretation.
      - Upon successful verification of the evidence, if its nonce is included
      in the evidence, the verifier application can be sure that the
      evidence is fresh.

- Optional parameters semantics are the opposite of that of custom claims:
  - They are TEE and evidence format specific
  - They are interpreted and processed by OE SDK attester and verifier plugins
    - Typically, optional parameters are provided by a verifier to an attester,
    so the attester can generate the correct evidence that can be
    verified by the verifier
  - They are not interpreted nor processed by attester / verifier
  application software
  - An SGX target info for local  attestation is a good example of
  optional parameter, as explained in the paragraphs below.

For SGX local attestation, the SGX target info generated by a
verifier enclave for an attester enclave is a perfect fit for the optional
parameters in the attester enclave's call to `oe_get_evidence()`:
- The target info is SGX specific, and is not parsed nor interpreted
by the TEE-agnostic application code.
- The SGX target info is generated by the function
`oe_get_verifier_settings()` of the SGX local attestation verifier plugin,
and passed by the calling verifier application as an opaque blob to an
attester enclave.
- The attester enclave invokes its SGX local attestation attester plugin via
`oe_get_evidence()`, passing in the received SGX target info as an opaque blob,
to generate an evidence containing the SGX report targeted for the
verifier enclave.
- This SGX report can only be verified by the verifier plugin of the verifier
enclave that generated the SGX target info.
Any other verifier enclaves, either running on the local or a remote platform,
won’t be able to verify this SGX report.

## Attester – Verifier Security Model and TEE Agnostic Design

- The OE SDK is designed for attester and verifier software to be TEE agnostic,
so that the same source code can be built for and run on different platforms
- But owners of attesters and verifiers define their security policies,
and the policies are not TEE agnostic. For example:
  - The policies define which TEEs, platforms and configurations are trusted
  to run the attesters and verifiers.
    - They also define security properties of these entities, e.g. keypairs
    and certs, service provider ID / SPID for SGX EPID evidence, etc.
    These security properties are required for attestation and secure
    communication.
  - The policies define the list of evidence formats acceptable to the verifiers.
    - Many acceptable evidence format are TEE specific. Examples include
    SGX location attestation evidence formats, SGX ECDSA evidence formats,
    and SGX EPID evidence formats.
- The OE SDK provides means for the attesters and verifiers to be built and
configured for specified TEEs and platforms, and to generate or verify evidences
in the list of acceptable formats as defined in the security policies.
  - The OE SDK attestation API enables the attesters and verifiers to register
  the plugins that are built, configured, and working
  properly, and enumerate the supported list of evidence formats covered by
  these plugins.
  For a specific attester or verifier instance, the supported list
  of evidence formats is not required to perfectly match the acceptable list
  defined in the security policies.

# Notes on SGX Plugins Design
## Options for Enclave-side Plugin Library Initialization

As described in the latest version (as of March 2020) of the design document
[Attestation: OE SDK Integration with Intel® SGX SDK quote-ex Library for Generation of Evidence in New Formats](https://github.com/openenclave/openenclave/blob/master/docs/DesignDocs/SGX_QuoteEx_Integration.md),
enclave-side plugin library initialization of attester plugins can be
triggered by application enclave call of the OE SDK API
`oe_get_attester_plugins()`.
During initialization, the plugin library enumerates supported evidence
formats, and returns a list of supported attester plugins.

In general, there are several options for initialization of enclave-side
plugin libraries while keeping application enclaves TEE agnostic.

In this section, we focus on the discussion of the options for initialization
of attester plugins. Similar options are available for initialization of
verifier plugins. Since verifier plugins are available both on the enclave
and host sides, their initialization on both sides are required.

1. Every enclave-side plugin library implements the same OE SDK API
`oe_get_attester_plugins()`.

    With this option, a build of an application enclave project can only link
    with a single attestation plugin library, to avoid function name collision.

2. Compile-time macro to convert from TEE-agnostic API to TEE-specific
implementation.

    With this option, application enclaves still call TEE-agnostic OE SDK API
    `oe_get_attester_plugins()`.
    But the OE SDK provides a macro definition of this function calling
    the TEE- and library-specific initialization functions of linked
    enclave-side plugin libraries.

    This option has the potential to support linking with multiple
    enclave-side plugin libraries in a single application enclave build
    configuration.
    The OE SDK build environment is required to provide a proper
    `oe_get_attester_plugins()` macro definition for every configuration
    it supports.

3. Every enclave-side plugin library registers its initialization function
with the OE SDK framework.

    The design document
    [OpenEnclave Modules](https://github.com/jhand2/openenclave/blob/global_module_initialization/docs/DesignDocs/openenclave_modules.md)
    describes how an enclave-side module can register its initialization
    function for invocation on first entry to the enclave (upon enclave load).

    With this option, the implementation of the OE SDK attestation framework
    provides a hook for enclave-side plugin libraries to register their
    initialization functions upon enclave load.

    If ordering between the initialization functions of multiple libraries is
    required, it can be supported by assigning different priorities to the
    initialization functions of these libraries when they are registered
    upon load.

    Later, when the application enclave calls `oe_get_attester_plugins()`,
    the implementation of this function in the OE SDK framework calls all the
    registered plugin library initialization functions in the order of their
    priorities, to initialize all plugin libraries and to enumerate all
    supported evidence formats by all the plugin libraries.

    This option allows the OE SDK framework to link with multiple plugin libraries.
    It even has the potential to support dynamic link / load of enclave-side
    plugin libraries, as long as the function `oe_get_attester_plugins()` is
    implemented as idempotent, so that it can be invoked multiple times,
    each time after a new plugin library is loaded.

# References

1. IETF draft [Remote Attestation Procedures Architecture](https://tools.ietf.org/html/draft-ietf-rats-architecture)
2. IETF draft [The Entity Attestation Token (EAT)](https://tools.ietf.org/html/draft-ietf-rats-eat)

# Authors

- Name: Shanwei Cen
    - email: shanwei.cen@intel.com
    - github user name: shnwc